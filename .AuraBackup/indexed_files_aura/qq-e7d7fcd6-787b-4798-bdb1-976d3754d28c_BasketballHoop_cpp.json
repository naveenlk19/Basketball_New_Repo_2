{"file_path": "Source/BasketBallGame/BasketballHoop.cpp", "file_id": "Source_BasketBallGame_BasketballHoop_cpp", "asset_path": "", "doc_id": "qq-e7d7fcd6-787b-4798-bdb1-976d3754d28c", "referencers": [], "dependencies": [], "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"BasketballHoop.h\"\n#include \"Basketball.h\"\n#include \"BasketBallGameGameMode.h\"\n#include \"BasketBallGameState.h\"\n#include \"Components/StaticMeshComponent.h\"\n#include \"PhysicsEngine/BodySetup.h\"\n#include \"Components/BoxComponent.h\"\n#include \"Components/SceneComponent.h\"\n#include \"Engine/World.h\"\n\nABasketballHoop::ABasketballHoop()\n{\n\t// Enable ticking if needed for animations later\n\tPrimaryActorTick.bCanEverTick = false;\n\n\t// Create root component (invisible positioning anchor)\n\tHoopRoot = CreateDefaultSubobject<USceneComponent>(TEXT(\"HoopRoot\"));\n\tRootComponent = HoopRoot;\n\n\t// Create backboard mesh\n\tBackboard = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"Backboard\"));\n\tBackboard->SetupAttachment(HoopRoot);\n\tBackboard->SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);\n\tBackboard->SetCollisionResponseToAllChannels(ECR_Block);\n\tBackboard->SetRelativeLocation(FVector(0.0f, 0.0f, 0.0f)); // At root (pivot is at backboard center)\n\n\t// Create rim mesh (attached to backboard)\n\tRim = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"Rim\"));\n\tRim->SetupAttachment(Backboard); // Attached to backboard, not root\n\tRim->SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);\n\tRim->SetCollisionResponseToAllChannels(ECR_Block);\n\tRim->SetRelativeLocation(FVector(15.0f, 0.0f, -45.0f)); // Forward from backboard, below center\n\n\t// Create top trigger (ball enters hoop) - attached to rim\n\tTopTrigger = CreateDefaultSubobject<UBoxComponent>(TEXT(\"TopTrigger\"));\n\tTopTrigger->SetupAttachment(Rim); // Attached to rim\n\tTopTrigger->SetBoxExtent(FVector(25.0f, 25.0f, 5.0f)); // 50cm diameter, 10cm height\n\tTopTrigger->SetRelativeLocation(FVector(0.0f, 0.0f, -5.0f)); // Just below rim center\n\tTopTrigger->SetCollisionEnabled(ECollisionEnabled::QueryOnly);\n\tTopTrigger->SetCollisionResponseToAllChannels(ECR_Ignore);\n\tTopTrigger->SetCollisionResponseToChannel(ECC_PhysicsBody, ECR_Overlap);\n\tTopTrigger->SetGenerateOverlapEvents(true);\n\n\t// Create bottom trigger (ball exits hoop - scores!)\n\tBottomTrigger = CreateDefaultSubobject<UBoxComponent>(TEXT(\"BottomTrigger\"));\n\tBottomTrigger->SetupAttachment(Rim); // Attached to rim\n\tBottomTrigger->SetBoxExtent(FVector(25.0f, 25.0f, 5.0f));\n\tBottomTrigger->SetRelativeLocation(FVector(0.0f, 0.0f, -45.0f)); // 40cm below top trigger (net length)\n\tBottomTrigger->SetCollisionEnabled(ECollisionEnabled::QueryOnly);\n\tBottomTrigger->SetCollisionResponseToAllChannels(ECR_Ignore);\n\tBottomTrigger->SetCollisionResponseToChannel(ECC_PhysicsBody, ECR_Overlap);\n\tBottomTrigger->SetGenerateOverlapEvents(true);\n\n\t// Default values\n\tPointValue = 2; // Standard 2-point shot\n\tHoopHeight = 305.0f; // 10 feet / 305cm\n\tbLastShotWasMake = false;\n\tCachedGameMode = nullptr;\n\tTotalMakes = 0;\n\tTotalAttempts = 0;\n}\n\nvoid ABasketballHoop::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// Use the actual mesh triangles for collision so the ball can pass through the rim opening\n\tif (Rim && Rim->GetStaticMesh())\n\t{\n\t\tUBodySetup* RimBodySetup = Rim->GetStaticMesh()->GetBodySetup();\n\t\tif (RimBodySetup)\n\t\t{\n\t\t\tRimBodySetup->CollisionTraceFlag = CTF_UseComplexAsSimple;\n\t\t\tRim->RecreatePhysicsState();\n\t\t}\n\t}\n\n\t// Bind overlap events\n\tTopTrigger->OnComponentBeginOverlap.AddDynamic(this, &ABasketballHoop::OnTopTriggerBeginOverlap);\n\tBottomTrigger->OnComponentBeginOverlap.AddDynamic(this, &ABasketballHoop::OnBottomTriggerBeginOverlap);\n\n\t// Cache GameMode reference\n\tif (UWorld* World = GetWorld())\n\t{\n\t\tCachedGameMode = World->GetAuthGameMode<ABasketBallGameGameMode>();\n\t}\n\tUE_LOG(LogTemp, Log, TEXT(\"Basketball Hoop initialized at height: %.0f cm\"), HoopHeight);\n}\n\nvoid ABasketballHoop::OnTopTriggerBeginOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor,\n\tUPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\t// Check if it's a basketball\n\tABasketball* Ball = Cast<ABasketball>(OtherActor);\n\tif (!Ball)\n\t{\n\t\treturn;\n\t}\n\n\t// Check if ball is moving downward (entering hoop from above)\n\tFVector BallVelocity = Ball->BallMesh->GetPhysicsLinearVelocity();\n\tif (BallVelocity.Z > 0.0f)\n\t{\n\t\t// Ball is moving upward, not a valid shot\n\t\treturn;\n\t}\n\n\t// Track this ball as having entered the top trigger\n\tBallsInTopTrigger.Add(Ball);\n\n\tUE_LOG(LogTemp, Log, TEXT(\"Ball entered hoop (top trigger): %s\"), *Ball->GetName());\n}\n\nvoid ABasketballHoop::OnBottomTriggerBeginOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor,\n\tUPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)\n{\n\t// Check if it's a basketball\n\tABasketball* Ball = Cast<ABasketball>(OtherActor);\n\tif (!Ball)\n\t{\n\t\treturn;\n\t}\n\n\t// CRITICAL: Check if ball was actually shot\n\tif (!Ball->bWasShot)\n\t{\n\t\t// Ball rolled in or fell in, not a valid shot attempt\n\t\treturn;\n\t}\n\n\t// CRITICAL: Check if ball already scored on this shot\n\tif (Ball->bHasScoredThisShot)\n\t{\n\t\t// Already counted, prevent double scoring\n\t\tBallsInTopTrigger.Remove(Ball);\n\t\treturn;\n\t}\n\n\t// Check if this ball previously entered the top trigger\n\tif (BallsInTopTrigger.Contains(Ball))\n\t{\n\t\t// Valid shot! Ball passed through both triggers in correct order\n\t\t\n\t\t// Mark ball as scored to prevent duplicate scoring\n\t\tBall->bHasScoredThisShot = true;\n\n\t\t// Remove from tracking set\n\t\tBallsInTopTrigger.Remove(Ball);\n\n\t\t// Register score with GameMode (SINGLE AUTHORITY)\n\t\tRegisterScoreWithGameMode(Ball);\n\n\t\t// Also update local stats (for backward compatibility)\n\t\tAwardPoints(Ball);\n\t}\n}\n\nvoid ABasketballHoop::RegisterScoreWithGameMode(ABasketball* Ball)\n{\n\tif (!Ball)\n\t{\n\t\treturn;\n\t}\n\n\t// Validate GameMode reference\n\tif (!CachedGameMode)\n\t{\n\t\tif (UWorld* World = GetWorld())\n\t\t{\n\t\t\tCachedGameMode = World->GetAuthGameMode<ABasketBallGameGameMode>();\n\t\t}\n\t}\n\n\tif (!CachedGameMode)\n\t{\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"BasketballHoop: Cannot register score - GameMode not found\"));\n\t\treturn;\n\t}\n\n\t// Check if match is still active\n\tif (ABasketBallGameState* GameState = CachedGameMode->GetBasketBallGameState())\n\t{\n\t\tif (!GameState->bMatchActive)\n\t\t{\n\t\t\tUE_LOG(LogTemp, Warning, TEXT(\"BasketballHoop: Score rejected - Match not active\"));\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// Register score with central authority\n\tCachedGameMode->RegisterScore(PointValue);\n\n\tUE_LOG(LogTemp, Log, TEXT(\"BASKET MADE! Ball: %s scored %d points\"), *Ball->GetName(), PointValue);\n}\n\nvoid ABasketballHoop::AwardPoints(ABasketball* Ball)\n{\n\tif (!Ball)\n\t{\n\t\treturn;\n\t}\n\n\t// Update statistics\n\tTotalMakes++;\n\tTotalAttempts++;\n\tbLastShotWasMake = true;\n\n\t// Broadcast score event\n\tOnScored.Broadcast(PointValue);\n\n\t// Trigger visual feedback (implemented in Blueprint)\n\tOnShotMade();\n\n\tUE_LOG(LogTemp, Display, TEXT(\"Score! +%d points. Total: %d/%d (%.1f%%)\"),\n\t\tPointValue, TotalMakes, TotalAttempts, (float)TotalMakes / TotalAttempts * 100.0f);\n}\n"}