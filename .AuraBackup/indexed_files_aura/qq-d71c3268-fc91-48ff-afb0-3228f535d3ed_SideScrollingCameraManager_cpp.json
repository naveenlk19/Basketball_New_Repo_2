{"file_path": "Source/BasketBallGame/Variant_SideScrolling/SideScrollingCameraManager.cpp", "file_id": "Source_BasketBallGame_Variant_SideScrolling_SideScrollingCameraManager_cpp", "asset_path": "", "doc_id": "qq-d71c3268-fc91-48ff-afb0-3228f535d3ed", "referencers": [], "dependencies": [], "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n\n#include \"SideScrollingCameraManager.h\"\n#include \"GameFramework/Pawn.h\"\n#include \"Engine/HitResult.h\"\n#include \"CollisionQueryParams.h\"\n#include \"Engine/World.h\"\n\nvoid ASideScrollingCameraManager::UpdateViewTarget(FTViewTarget& OutVT, float DeltaTime)\n{\n\t// ensure the view target is a pawn\n\tAPawn* TargetPawn = Cast<APawn>(OutVT.Target);\n\n\t// is our target valid?\n\tif (IsValid(TargetPawn))\n\t{\n\t\t// set the view target FOV and rotation\n\t\tOutVT.POV.Rotation = FRotator(0.0f, -90.0f, 0.0f);\n\t\tOutVT.POV.FOV = 65.0f;\n\n\t\t// cache the current location\n\t\tFVector CurrentActorLocation = OutVT.Target->GetActorLocation();\n\n\t\t// copy the current camera location\n\t\tFVector CurrentCameraLocation = GetCameraLocation();\n\n\t\t// calculate the \"zoom distance\" - in reality the distance we want to keep to the target\n\t\tfloat CurrentY = CurrentZoom + CurrentActorLocation.Y;\n\n\t\t// do first-time setup\n\t\tif (bSetup)\n\t\t{\n\t\t\t// lower the setup flag\n\t\t\tbSetup = false;\n\n\t\t\t// initialize the camera viewpoint and return\n\t\t\tOutVT.POV.Location.X = CurrentActorLocation.X;\n\t\t\tOutVT.POV.Location.Y = CurrentY;\n\t\t\tOutVT.POV.Location.Z = CurrentActorLocation.Z + CameraZOffset;\n\n\t\t\t// save the current camera height\n\t\t\tCurrentZ = OutVT.POV.Location.Z;\n\n\t\t\t// skip the rest of the calculations\n\t\t\treturn;\n\t\t}\n\n\t\t// check if the camera needs to update its height\n\t\tbool bZUpdate = false;\n\n\t\t// is the character moving vertically?\n\t\tif (FMath::IsNearlyZero(TargetPawn->GetVelocity().Z))\n\t\t{\n\t\t\t// determine if we need to do a height update\n\t\t\tbZUpdate = FMath::IsNearlyEqual(CurrentZ, CurrentCameraLocation.Z, 25.0f);\n\n\t\t} else {\n\n\t\t\t// run a trace below the character to determine if we need to do a height update\n\t\t\tFHitResult OutHit;\n\n\t\t\tconst FVector End = CurrentActorLocation + FVector(0.0f, 0.0f, -1000.0f);\n\n\t\t\tFCollisionQueryParams QueryParams;\n\t\t\tQueryParams.AddIgnoredActor(TargetPawn);\n\n\t\t\t// only update height if we're not about to hit ground\n\t\t\tbZUpdate = !GetWorld()->LineTraceSingleByChannel(OutHit, CurrentActorLocation, End, ECC_Visibility, QueryParams);\n\n\t\t}\n\n\t\t// do we need to do a height update?\n\t\tif (bZUpdate)\n\t\t{\n\n\t\t\t// set the height goal from the actor location\n\t\t\tCurrentZ = CurrentActorLocation.Z;\n\n\t\t} else {\n\n\t\t\t// are we close enough to the target height?\n\t\t\tif (FMath::IsNearlyEqual(CurrentZ, CurrentActorLocation.Z, 100.0f))\n\t\t\t{\n\t\t\t\t// set the height goal from the actor location\n\t\t\t\tCurrentZ = CurrentActorLocation.Z;\n\n\t\t\t} else {\n\n\t\t\t\t// blend the height towards the actor location\n\t\t\t\tCurrentZ = FMath::FInterpTo(CurrentZ, CurrentActorLocation.Z, DeltaTime, 2.0f);\n\t\t\t\t\n\t\t\t}\n\n\t\t}\n\n\t\t// clamp the X axis to the min and max camera bounds\n\t\tfloat CurrentX = FMath::Clamp(CurrentActorLocation.X, CameraXMinBounds, CameraXMaxBounds);\n\n\t\t// blend towards the new camera location and update the output\n\t\tFVector TargetCameraLocation(CurrentX, CurrentY, CurrentZ);\n\n\t\tOutVT.POV.Location = FMath::VInterpTo(CurrentCameraLocation, TargetCameraLocation, DeltaTime, 2.0f);\n\t}\n}"}