{"file_path": "Source/BasketBallGame/Variant_SideScrolling/SideScrollingCharacter.cpp", "file_id": "Source_BasketBallGame_Variant_SideScrolling_SideScrollingCharacter_cpp", "asset_path": "", "doc_id": "qq-7d555f80-c635-441f-9b39-21841e8d3838", "referencers": [], "dependencies": [], "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n\n#include \"SideScrollingCharacter.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"Components/CapsuleComponent.h\"\n#include \"Camera/CameraComponent.h\"\n#include \"Components/InputComponent.h\"\n#include \"InputActionValue.h\"\n#include \"EnhancedInputComponent.h\"\n#include \"InputAction.h\"\n#include \"Engine/World.h\"\n#include \"SideScrollingInteractable.h\"\n#include \"Kismet/KismetMathLibrary.h\"\n#include \"TimerManager.h\"\n\nASideScrollingCharacter::ASideScrollingCharacter()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// create the camera component\n\tCamera = CreateDefaultSubobject<UCameraComponent>(TEXT(\"Camera\"));\n\tCamera->SetupAttachment(RootComponent);\n\n\tCamera->SetRelativeLocationAndRotation(FVector(0.0f, 300.0f, 0.0f), FRotator(0.0f, -90.0f, 0.0f));\n\n\t// configure the collision capsule\n\tGetCapsuleComponent()->SetCapsuleSize(35.0f, 90.0f);\n\n\t// configure the Pawn properties\n\tbUseControllerRotationYaw = false;\n\n\t// configure the character movement component\n\tGetCharacterMovement()->GravityScale = 1.75f;\n\tGetCharacterMovement()->MaxAcceleration = 1500.0f;\n\tGetCharacterMovement()->BrakingFrictionFactor = 1.0f;\n\tGetCharacterMovement()->bUseSeparateBrakingFriction = true;\n\tGetCharacterMovement()->Mass = 500.0f;\n\n\tGetCharacterMovement()->SetWalkableFloorAngle(75.0f);\n\tGetCharacterMovement()->MaxWalkSpeed = 500.0f;\n\tGetCharacterMovement()->MinAnalogWalkSpeed = 20.0f;\n\tGetCharacterMovement()->BrakingDecelerationWalking = 2000.0f;\n\tGetCharacterMovement()->bIgnoreBaseRotation = true;\n\n\tGetCharacterMovement()->PerchRadiusThreshold = 15.0f;\n\tGetCharacterMovement()->LedgeCheckThreshold = 6.0f;\n\n\tGetCharacterMovement()->JumpZVelocity = 750.0f;\n\tGetCharacterMovement()->AirControl = 1.0f;\n\n\tGetCharacterMovement()->RotationRate = FRotator(0.0f, 750.0f, 0.0f);\n\tGetCharacterMovement()->bOrientRotationToMovement = true;\n\n\tGetCharacterMovement()->SetPlaneConstraintNormal(FVector(0.0f, 1.0f, 0.0f));\n\tGetCharacterMovement()->bConstrainToPlane = true;\n\n\t// enable double jump and coyote time\n\tJumpMaxCount = 3;\n}\n\nvoid ASideScrollingCharacter::EndPlay(EEndPlayReason::Type EndPlayReason)\n{\n\tSuper::EndPlay(EndPlayReason);\n\n\t// clear the wall jump timer\n\tGetWorld()->GetTimerManager().ClearTimer(WallJumpTimer);\n}\n\nvoid ASideScrollingCharacter::SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\t// Set up action bindings\n\tif (UEnhancedInputComponent* EnhancedInputComponent = Cast<UEnhancedInputComponent>(PlayerInputComponent))\n\t{\n\t\t// Jumping\n\t\tEnhancedInputComponent->BindAction(JumpAction, ETriggerEvent::Started, this, &ASideScrollingCharacter::DoJumpStart);\n\t\tEnhancedInputComponent->BindAction(JumpAction, ETriggerEvent::Completed, this, &ASideScrollingCharacter::DoJumpEnd);\n\n\t\t// Interacting\n\t\tEnhancedInputComponent->BindAction(InteractAction, ETriggerEvent::Triggered, this, &ASideScrollingCharacter::DoInteract);\n\n\t\t// Moving\n\t\tEnhancedInputComponent->BindAction(MoveAction, ETriggerEvent::Triggered, this, &ASideScrollingCharacter::Move);\n\n\t\t// Dropping from platform\n\t\tEnhancedInputComponent->BindAction(DropAction, ETriggerEvent::Triggered, this, &ASideScrollingCharacter::Drop);\n\t\tEnhancedInputComponent->BindAction(DropAction, ETriggerEvent::Completed, this, &ASideScrollingCharacter::DropReleased);\n\n\t}\n}\n\nvoid ASideScrollingCharacter::NotifyHit(class UPrimitiveComponent* MyComp, AActor* Other, class UPrimitiveComponent* OtherComp, bool bSelfMoved, FVector HitLocation, FVector HitNormal, FVector NormalImpulse, const FHitResult& Hit)\n{\n\tSuper::NotifyHit(MyComp, Other, OtherComp, bSelfMoved, HitLocation, HitNormal, NormalImpulse, Hit);\n\n\t// only apply push impulse if we're falling\n\tif (!GetCharacterMovement()->IsFalling())\n\t{\n\t\treturn;\n\t}\n\n\t// ensure the colliding component is valid\n\tif (OtherComp)\n\t{\n\t\t// ensure the component is movable and simulating physics\n\t\tif (OtherComp->Mobility == EComponentMobility::Movable && OtherComp->IsSimulatingPhysics())\n\t\t{\n\t\t\tconst FVector PushDir = FVector(ActionValueY > 0.0f ? 1.0f : -1.0f, 0.0f, 0.0f);\n\n\t\t\t// push the component away\n\t\t\tOtherComp->AddImpulse(PushDir * JumpPushImpulse, NAME_None, true);\n\t\t}\n\t}\n}\n\nvoid ASideScrollingCharacter::Landed(const FHitResult& Hit)\n{\n\t// reset the double jump\n\tbHasDoubleJumped = false;\n}\n\nvoid ASideScrollingCharacter::OnMovementModeChanged(EMovementMode PrevMovementMode, uint8 PreviousCustomMode /*= 0*/)\n{\n\tSuper::OnMovementModeChanged(PrevMovementMode, PreviousCustomMode);\n\n\t// are we falling?\n\tif (GetCharacterMovement()->MovementMode == EMovementMode::MOVE_Falling)\n\t{\n\t\t// save the game time when we started falling, so we can check it later for coyote time jumps\n\t\tLastFallTime = GetWorld()->GetTimeSeconds();\n\t}\n}\n\nvoid ASideScrollingCharacter::Move(const FInputActionValue& Value)\n{\n\tFVector2D MoveVector = Value.Get<FVector2D>();\n\n\t// route the input\n\tDoMove(MoveVector.Y);\n}\n\nvoid ASideScrollingCharacter::Drop(const FInputActionValue& Value)\n{\n\t// route the input\n\tDoDrop(Value.Get<float>());\n}\n\nvoid ASideScrollingCharacter::DropReleased(const FInputActionValue& Value)\n{\n\t// reset the input\n\tDoDrop(0.0f);\n}\n\nvoid ASideScrollingCharacter::DoMove(float Forward)\n{\n\t// is movement temporarily disabled after wall jumping?\n\tif (!bHasWallJumped)\n\t{\n\t\t// save the movement values\n\t\tActionValueY = Forward;\n\n\t\t// figure out the movement direction\n\t\tconst FVector MoveDir = FVector(1.0f, Forward > 0.0f ? 0.1f : -0.1f, 0.0f);\n\n\t\t// apply the movement input\n\t\tAddMovementInput(MoveDir, Forward);\n\t}\n}\n\nvoid ASideScrollingCharacter::DoDrop(float Value)\n{\n\t// save the movement value\n\tDropValue = Value;\n}\n\nvoid ASideScrollingCharacter::DoJumpStart()\n{\n\t// handle advanced jump behaviors\n\tMultiJump();\n}\n\nvoid ASideScrollingCharacter::DoJumpEnd()\n{\n\tStopJumping();\n}\n\nvoid ASideScrollingCharacter::DoInteract()\n{\n\t// do a sphere trace to look for interactive objects\n\tFHitResult OutHit;\n\n\tconst FVector Start = GetActorLocation();\n\tconst FVector End = Start + FVector(100.0f, 0.0f, 0.0f);\n\n\tFCollisionShape ColSphere;\n\tColSphere.SetSphere(InteractionRadius);\n\n\tFCollisionObjectQueryParams ObjectParams;\n\tObjectParams.AddObjectTypesToQuery(ECC_Pawn);\n\tObjectParams.AddObjectTypesToQuery(ECC_WorldDynamic);\n\n\tFCollisionQueryParams QueryParams;\n\tQueryParams.AddIgnoredActor(this);\n\n\tif (GetWorld()->SweepSingleByObjectType(OutHit, Start, End, FQuat::Identity, ObjectParams, ColSphere, QueryParams))\n\t{\n\t\t// have we hit an interactable?\n\t\tif (ISideScrollingInteractable* Interactable = Cast<ISideScrollingInteractable>(OutHit.GetActor()))\n\t\t{\n\t\t\t// interact\n\t\t\tInteractable->Interaction(this);\n\t\t}\n\t}\n}\n\nvoid ASideScrollingCharacter::MultiJump()\n{\n\t// does the user want to drop to a lower platform?\n\tif (DropValue > 0.0f)\n\t{\n\t\tCheckForSoftCollision();\n\t\treturn;\n\t}\n\n\t// reset the drop value\n\tDropValue = 0.0f;\n\n\t// if we're grounded, disregard advanced jump logic\n\tif (!GetCharacterMovement()->IsFalling())\n\t{\n\t\tJump();\n\t\treturn;\n\t}\n\n\t// if we have a horizontal input, try for wall jump first\n\tif (!bHasWallJumped && !FMath::IsNearlyZero(ActionValueY))\n\t{\n\t\t// trace ahead of the character for walls\n\t\tFHitResult OutHit;\n\n\t\tconst FVector Start = GetActorLocation();\n\t\tconst FVector End = Start + (FVector(ActionValueY > 0.0f ? 1.0f : -1.0f, 0.0f, 0.0f) * WallJumpTraceDistance);\n\n\t\tFCollisionQueryParams QueryParams;\n\t\tQueryParams.AddIgnoredActor(this);\n\n\t\tGetWorld()->LineTraceSingleByChannel(OutHit, Start, End, ECC_Visibility, QueryParams);\n\n\t\tif (OutHit.bBlockingHit)\n\t\t{\n\t\t\t// rotate to the bounce direction\n\t\t\tconst FRotator BounceRot = UKismetMathLibrary::MakeRotFromX(OutHit.ImpactNormal);\n\t\t\tSetActorRotation(FRotator(0.0f, BounceRot.Yaw, 0.0f));\n\n\t\t\t// calculate the impulse vector\n\t\t\tFVector WallJumpImpulse = OutHit.ImpactNormal * WallJumpHorizontalImpulse;\n\t\t\tWallJumpImpulse.Z = GetCharacterMovement()->JumpZVelocity * WallJumpVerticalMultiplier;\n\n\t\t\t// launch the character away from the wall\n\t\t\tLaunchCharacter(WallJumpImpulse, true, true);\n\n\t\t\t// enable wall jump lockout for a bit\n\t\t\tbHasWallJumped = true;\n\n\t\t\t// schedule wall jump lockout reset\n\t\t\tGetWorld()->GetTimerManager().SetTimer(WallJumpTimer, this, &ASideScrollingCharacter::ResetWallJump, DelayBetweenWallJumps, false);\n\n\t\t\treturn;\n\t\t}\n\t}\n\n\n\n\t// test for double jump only if we haven't already tested for wall jump\n\tif (!bHasWallJumped)\n\t{\n\t\t// are we still within coyote time frames?\n\t\tif (GetWorld()->GetTimeSeconds() - LastFallTime < MaxCoyoteTime)\n\t\t{\n\t\t\tUE_LOG(LogTemp, Warning, TEXT(\"Coyote Jump\"));\n\n\t\t\t// use the built-in CMC functionality to do the jump\n\t\t\tJump();\n\n\t\t// no coyote time jump\n\t\t} else {\n\t\t\n\t\t\t// The movement component handles double jump but we still need to manage the flag for animation\n\t\t\tif (!bHasDoubleJumped)\n\t\t\t{\n\t\t\t\t// raise the double jump flag\n\t\t\t\tbHasDoubleJumped = true;\n\n\t\t\t\t// let the CMC handle jump\n\t\t\t\tJump();\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid ASideScrollingCharacter::CheckForSoftCollision()\n{\n\t// reset the drop value\n\tDropValue = 0.0f;\n\n\t// trace down \n\tFHitResult OutHit;\n\n\tconst FVector Start = GetActorLocation();\n\tconst FVector End = Start + (FVector::DownVector * SoftCollisionTraceDistance);\n\n\tFCollisionObjectQueryParams ObjectParams;\n\tObjectParams.AddObjectTypesToQuery(SoftCollisionObjectType);\n\n\tFCollisionQueryParams QueryParams;\n\tQueryParams.AddIgnoredActor(this);\n\n\tGetWorld()->LineTraceSingleByObjectType(OutHit, Start, End, ObjectParams, QueryParams);\n\n\t// did we hit a soft floor?\n\tif (OutHit.GetActor())\n\t{\n\t\t// drop through the floor\n\t\tSetSoftCollision(true);\n\t}\n}\n\nvoid ASideScrollingCharacter::ResetWallJump()\n{\n\t// reset the wall jump flag\n\tbHasWallJumped = false;\n}\n\nvoid ASideScrollingCharacter::SetSoftCollision(bool bEnabled)\n{\n\t// enable or disable collision response to the soft collision channel\n\tGetCapsuleComponent()->SetCollisionResponseToChannel(SoftCollisionObjectType, bEnabled ? ECR_Ignore : ECR_Block);\n}\n\nbool ASideScrollingCharacter::HasDoubleJumped() const\n{\n\treturn bHasDoubleJumped;\n}\n\nbool ASideScrollingCharacter::HasWallJumped() const\n{\n\treturn bHasWallJumped;\n}\n"}