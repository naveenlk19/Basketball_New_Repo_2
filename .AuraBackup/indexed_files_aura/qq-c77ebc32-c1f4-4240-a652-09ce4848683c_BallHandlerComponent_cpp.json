{"file_path": "Source/BasketBallGame/BallHandlerComponent.cpp", "file_id": "Source_BasketBallGame_BallHandlerComponent_cpp", "asset_path": "", "doc_id": "qq-c77ebc32-c1f4-4240-a652-09ce4848683c", "referencers": [], "dependencies": [], "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"BallHandlerComponent.h\"\n#include \"Basketball.h\"\n#include \"GameFramework/Character.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"Camera/CameraComponent.h\"\n#include \"Engine/World.h\"\n\nUBallHandlerComponent::UBallHandlerComponent()\n{\n\t// Component doesn't need to tick\n\tPrimaryComponentTick.bCanEverTick = false;\n\n\t// Default values\n\tBallSocketName = FName(TEXT(\"hand_r_ball\")); // Common socket name for right hand\n\tPickupRange = 200.0f; // 2 meters\n\tMaxShotPower = 1500.0f; // 15 meters/sec\n\tChargeTime = 1.5f; // 1.5 seconds for full charge\n\tCurrentCharge = 0.0f;\n\tbIsCharging = false;\n\tCurrentBall = nullptr;\n}\n\nvoid UBallHandlerComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nbool UBallHandlerComponent::TryPickupBall()\n{\n\t// Already holding a ball\n\tif (HasBall())\n\t{\n\t\treturn false;\n\t}\n\n\t// Find nearest ball\n\tABasketball* NearestBall = FindNearestBall();\n\tif (!NearestBall)\n\t{\n\t\treturn false;\n\t}\n\n\t// Check if ball can be picked up\n\tif (!NearestBall->CanBePickedUp())\n\t{\n\t\treturn false;\n\t}\n\n\t// Get owning character\n\tACharacter* Character = Cast<ACharacter>(GetOwner());\n\tif (!Character)\n\t{\n\t\treturn false;\n\t}\n\n\tUSkeletalMeshComponent* Mesh = Character->GetMesh();\n\tif (!Mesh || !Mesh->DoesSocketExist(BallSocketName))\n\t{\n\t\treturn false;\n\t}\n\n\t// Disable ball physics before attaching\n\tNearestBall->DisablePhysics();\n\tNearestBall->bIsHeld = true;\n\n\t// Attach ball to the HAND socket (not pelvis)\n\tNearestBall->AttachToComponent(\n\t\tMesh,\n\t\tFAttachmentTransformRules::SnapToTargetNotIncludingScale,\n\t\tBallSocketName\n\t);\n\tUE_LOG(LogTemp, Warning, TEXT(\"Hand socket valid: %d\"),\n\t\tMesh->DoesSocketExist(BallSocketName));\n\tCurrentBall = NearestBall;\n\treturn true;\n}\n\n\nvoid UBallHandlerComponent::DropBall()\n{\n\tif (!HasBall())\n\t{\n\t\treturn;\n\t}\n\n\t// Update ball state before detaching\n\tCurrentBall->bIsHeld = false;\n\t\n\tCurrentBall->DetachFromActor(FDetachmentTransformRules::KeepWorldTransform);\n\tCurrentBall->EnablePhysics(); // or your existing logic\n\n\tCurrentBall = nullptr;\n}\n\n\nABasketball* UBallHandlerComponent::FindNearestBall()\n{\n\tAActor* Owner = GetOwner();\n\tif (!Owner)\n\t{\n\t\treturn nullptr;\n\t}\n\n\tUWorld* World = GetWorld();\n\tif (!World)\n\t{\n\t\treturn nullptr;\n\t}\n\n\t// Get all basketball actors in world\n\tTArray<AActor*> FoundBalls;\n\tUGameplayStatics::GetAllActorsOfClass(World, ABasketball::StaticClass(), FoundBalls);\n\n\tif (FoundBalls.Num() == 0)\n\t{\n\t\treturn nullptr;\n\t}\n\n\t// Find closest ball within range\n\tABasketball* ClosestBall = nullptr;\n\tfloat ClosestDistance = PickupRange;\n\tFVector OwnerLocation = Owner->GetActorLocation();\n\n\tfor (AActor* Actor : FoundBalls)\n\t{\n\t\tABasketball* Ball = Cast<ABasketball>(Actor);\n\t\tif (!Ball || !Ball->CanBePickedUp())\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tfloat Distance = FVector::Dist(OwnerLocation, Ball->GetActorLocation());\n\t\tif (Distance < ClosestDistance)\n\t\t{\n\t\t\tClosestDistance = Distance;\n\t\t\tClosestBall = Ball;\n\t\t}\n\t}\n\n\treturn ClosestBall;\n}\n\nvoid UBallHandlerComponent::SetBall(ABasketball* Ball)\n{\n\tif (!Ball)\n\t{\n\t\treturn;\n\t}\n\n\t// Drop current ball if holding one\n\tif (HasBall())\n\t{\n\t\tDropBall();\n\t}\n\n\t// Attach new ball\n\tBall->AttachToCharacter(GetOwner(), BallSocketName);\n\tCurrentBall = Ball;\n}\n\nvoid UBallHandlerComponent::StartCharging()\n{\n\t// Can only charge if holding a ball\n\tif (!HasBall())\n\t{\n\t\treturn;\n\t}\n\n\t// Start charging\n\tbIsCharging = true;\n\tChargeStartTime = GetWorld()->GetTimeSeconds();\n\tCurrentCharge = 0.0f;\n}\n\nvoid UBallHandlerComponent::ShootBall()\n{\n\t// Must be charging and have a ball\n\tif (!bIsCharging || !HasBall())\n\t{\n\t\treturn;\n\t}\n\n\t// Calculate final charge (0.0 to 1.0)\n\tfloat ElapsedTime = GetWorld()->GetTimeSeconds() - ChargeStartTime;\n\tCurrentCharge = FMath::Clamp(ElapsedTime / ChargeTime, 0.0f, 1.0f);\n\n\t// Get owner character\n\tACharacter* Character = Cast<ACharacter>(GetOwner());\n\tif (!Character)\n\t{\n\t\treturn;\n\t}\n\n\t// Find camera component for aim direction\n\tUCameraComponent* Camera = Character->FindComponentByClass<UCameraComponent>();\n\tFVector LaunchDirection;\n\t\n\tif (Camera)\n\t{\n\t\t// Use camera forward vector for aim\n\t\tLaunchDirection = Camera->GetForwardVector();\n\t}\n\telse\n\t{\n\t\t// Fallback to actor forward if no camera\n\t\tLaunchDirection = Character->GetActorForwardVector();\n\t}\n\n\t// Add upward arc (45 degrees at full charge, 30 degrees at minimum)\n\tfloat ArcAngle = FMath::Lerp(30.0f, 45.0f, CurrentCharge);\n\tFRotator ArcRotation = FRotator(ArcAngle, 0.0f, 0.0f);\n\tLaunchDirection = ArcRotation.RotateVector(LaunchDirection);\n\tLaunchDirection.Normalize();\n\n\t// Calculate launch velocity based on charge\n\tfloat LaunchSpeed = MaxShotPower * FMath::Lerp(0.3f, 1.0f, CurrentCharge); // Minimum 30% power\n\tFVector LaunchVelocity = LaunchDirection * LaunchSpeed;\n\n\t// Get ball reference before dropping\n\tABasketball* BallToShoot = CurrentBall;\n\n\t// Detach ball (but keep reference)\n\tCurrentBall->DetachFromActor(FDetachmentTransformRules::KeepWorldTransform);\n\tCurrentBall->bIsHeld = false;\n\tCurrentBall = nullptr;\n\n\t// Enable physics and apply launch velocity\n\tBallToShoot->EnablePhysics();\n\tBallToShoot->BallMesh->SetPhysicsLinearVelocity(LaunchVelocity);\n\n\t// Reset charge state\n\tbIsCharging = false;\n\tCurrentCharge = 0.0f;\n\n\tUE_LOG(LogTemp, Log, TEXT(\"Shot ball with %d%% power (%.0f cm/s)\"), \n\t\tFMath::RoundToInt(CurrentCharge * 100.0f), LaunchSpeed);\n}\n"}