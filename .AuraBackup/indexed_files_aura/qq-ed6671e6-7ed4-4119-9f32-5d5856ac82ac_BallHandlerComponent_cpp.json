{"file_path": "Source/BasketBallGame/BallHandlerComponent.cpp", "file_id": "Source_BasketBallGame_BallHandlerComponent_cpp", "asset_path": "", "doc_id": "qq-ed6671e6-7ed4-4119-9f32-5d5856ac82ac", "referencers": [], "dependencies": [], "content": "\ufeff// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"BallHandlerComponent.h\"\n#include \"Basketball.h\"\n#include \"BasketBallGameGameMode.h\"\n#include \"GameFramework/Character.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"Camera/CameraComponent.h\"\n#include \"Engine/World.h\"\n#include \"DrawDebugHelpers.h\"\n\nUBallHandlerComponent::UBallHandlerComponent()\n{\n\t// Enable tick for trajectory preview updates\n\tPrimaryComponentTick.bCanEverTick = true;\n\tPrimaryComponentTick.bStartWithTickEnabled = true;\n\n\t// Ball handling defaults\n\tBallSocketName = FName(TEXT(\"hand_r_ball\"));\n\tPickupRange = 200.0f;\n\tCurrentBall = nullptr;\n\n\t// Shooting defaults\n\tMaxShotPower = 1500.0f;\n\tMinPowerFraction = 0.4f;\n\tChargeTime = 1.5f;\n\tCurrentCharge = 0.0f;\n\tbIsCharging = false;\n\tMinArcAngle = 45.0f;\n\tMaxArcAngle = 55.0f;\n\n\t// Trajectory preview defaults\n\tTrajectoryPointCount = 30;\n\tTrajectoryTimeStep = 0.05f; // 50ms between points\n\tbShowTrajectory = true;\n}\n\nvoid UBallHandlerComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n}\n\nvoid UBallHandlerComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (bIsCharging && HasBall())\n\t{\n\t\t// Update charge value in real-time\n\t\tfloat ElapsedTime = GetWorld()->GetTimeSeconds() - ChargeStartTime;\n\t\tCurrentCharge = FMath::Clamp(ElapsedTime / ChargeTime, 0.0f, 1.0f);\n\n\t\t// Update trajectory preview\n\t\tif (bShowTrajectory)\n\t\t{\n\t\t\tUpdateTrajectoryPreview();\n\t\t}\n\t}\n}\n\n// ======== Ball Handling ========\n\nbool UBallHandlerComponent::TryPickupBall()\n{\n\tif (HasBall())\n\t{\n\t\treturn false;\n\t}\n\n\tABasketball* NearestBall = FindNearestBall();\n\tif (!NearestBall)\n\t{\n\t\treturn false;\n\t}\n\n\tif (!NearestBall->CanBePickedUp())\n\t{\n\t\treturn false;\n\t}\n\n\tACharacter* Character = Cast<ACharacter>(GetOwner());\n\tif (!Character)\n\t{\n\t\treturn false;\n\t}\n\n\tUSkeletalMeshComponent* Mesh = Character->GetMesh();\n\tif (!Mesh || !Mesh->DoesSocketExist(BallSocketName))\n\t{\n\t\treturn false;\n\t}\n\n\tNearestBall->DisablePhysics();\n\tNearestBall->bIsHeld = true;\n\n\tNearestBall->AttachToComponent(\n\t\tMesh,\n\t\tFAttachmentTransformRules::SnapToTargetNotIncludingScale,\n\t\tBallSocketName\n\t);\n\n\tCurrentBall = NearestBall;\n\tUE_LOG(LogTemp, Log, TEXT(\"Picked up ball: %s\"), *NearestBall->GetName());\n\treturn true;\n}\n\nvoid UBallHandlerComponent::DropBall()\n{\n\tif (!HasBall())\n\t{\n\t\treturn;\n\t}\n\n\tCurrentBall->bIsHeld = false;\n\tCurrentBall->DetachFromActor(FDetachmentTransformRules::KeepWorldTransform);\n\tCurrentBall->EnablePhysics();\n\tCurrentBall = nullptr;\n\n\t// Clear trajectory if showing\n\tClearTrajectoryPreview();\n}\n\nABasketball* UBallHandlerComponent::FindNearestBall()\n{\n\tAActor* Owner = GetOwner();\n\tif (!Owner)\n\t{\n\t\treturn nullptr;\n\t}\n\n\tUWorld* World = GetWorld();\n\tif (!World)\n\t{\n\t\treturn nullptr;\n\t}\n\n\tTArray<AActor*> FoundBalls;\n\tUGameplayStatics::GetAllActorsOfClass(World, ABasketball::StaticClass(), FoundBalls);\n\n\tif (FoundBalls.Num() == 0)\n\t{\n\t\treturn nullptr;\n\t}\n\n\tABasketball* ClosestBall = nullptr;\n\tfloat ClosestDistance = PickupRange;\n\tFVector OwnerLocation = Owner->GetActorLocation();\n\n\tfor (AActor* Actor : FoundBalls)\n\t{\n\t\tABasketball* Ball = Cast<ABasketball>(Actor);\n\t\tif (!Ball || !Ball->CanBePickedUp())\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tfloat Distance = FVector::Dist(OwnerLocation, Ball->GetActorLocation());\n\t\tif (Distance < ClosestDistance)\n\t\t{\n\t\t\tClosestDistance = Distance;\n\t\t\tClosestBall = Ball;\n\t\t}\n\t}\n\n\treturn ClosestBall;\n}\n\nvoid UBallHandlerComponent::SetBall(ABasketball* Ball)\n{\n\tif (!Ball)\n\t{\n\t\treturn;\n\t}\n\n\tif (HasBall())\n\t{\n\t\tDropBall();\n\t}\n\n\tBall->AttachToCharacter(GetOwner(), BallSocketName);\n\tCurrentBall = Ball;\n}\n\n// ======== Shooting ========\n\nvoid UBallHandlerComponent::StartCharging()\n{\n\tif (!HasBall())\n\t{\n\t\treturn;\n\t}\n\n\tbIsCharging = true;\n\tChargeStartTime = GetWorld()->GetTimeSeconds();\n\tCurrentCharge = 0.0f;\n\n\tUE_LOG(LogTemp, Log, TEXT(\"Started charging shot\"));\n}\n\nFVector UBallHandlerComponent::CalculateLaunchVelocity() const\n{\n\tACharacter* Character = Cast<ACharacter>(GetOwner());\n\tif (!Character)\n\t{\n\t\treturn FVector::ZeroVector;\n\t}\n\n\t// Get aim direction from camera\n\tUCameraComponent* Camera = Character->FindComponentByClass<UCameraComponent>();\n\tFVector AimDirection;\n\n\tif (Camera)\n\t{\n\t\tAimDirection = Camera->GetForwardVector();\n\t}\n\telse\n\t{\n\t\tAimDirection = Character->GetActorForwardVector();\n\t}\n\n\t// Flatten aim to horizontal plane\n\tFVector HorizontalAim = FVector(AimDirection.X, AimDirection.Y, 0.0f).GetSafeNormal();\n\n\t// Interpolate arc angle based on charge\n\tfloat ArcAngleDeg = FMath::Lerp(MinArcAngle, MaxArcAngle, CurrentCharge);\n\tfloat ArcAngleRad = FMath::DegreesToRadians(ArcAngleDeg);\n\n\t// Combine horizontal aim with upward component\n\tFVector LaunchDirection = HorizontalAim * FMath::Cos(ArcAngleRad) + FVector::UpVector * FMath::Sin(ArcAngleRad);\n\n\t// Calculate speed: interpolate between min and max power\n\tfloat LaunchSpeed = MaxShotPower * FMath::Lerp(MinPowerFraction, 1.0f, CurrentCharge);\n\n\treturn LaunchDirection * LaunchSpeed;\n}\n\nvoid UBallHandlerComponent::ShootBall()\n{\n\tif (!bIsCharging || !HasBall())\n\t{\n\t\treturn;\n\t}\n\n\t// Final charge clamp\n\tconst float ElapsedTime = GetWorld()->GetTimeSeconds() - ChargeStartTime;\n\tCurrentCharge = FMath::Clamp(ElapsedTime / ChargeTime, 0.0f, 1.0f);\n\n\tconst FVector LaunchVelocity = CalculateLaunchVelocity();\n\tif (LaunchVelocity.IsNearlyZero())\n\t{\n\t\tbIsCharging = false;\n\t\tCurrentCharge = 0.0f;\n\t\tClearTrajectoryPreview();\n\t\treturn;\n\t}\n\n\tABasketball* BallToShoot = CurrentBall;\n\tif (!BallToShoot)\n\t{\n\t\treturn;\n\t}\n\n\t// Detach ball from hand\n\tBallToShoot->DetachFromActor(FDetachmentTransformRules::KeepWorldTransform);\n\tBallToShoot->bIsHeld = false;\n\tCurrentBall = nullptr;\n\n\t// \ud83d\udd25 CRITICAL: Mark shot state\n\tBallToShoot->bWasShot = true;\n\tBallToShoot->bHasScoredThisShot = false;\n\n\t// Apply physics\n\tBallToShoot->EnablePhysics();\n\tBallToShoot->BallMesh->SetPhysicsLinearVelocity(LaunchVelocity);\n\n\tUE_LOG(LogTemp, Warning,\n\t\tTEXT(\"Shot ball | Charge=%.2f | Speed=%.0f\"),\n\t\tCurrentCharge,\n\t\tLaunchVelocity.Size());\n\n\t// Register attempt with authority\n\tif (UWorld* World = GetWorld())\n\t{\n\t\tif (ABasketBallGameGameMode* GM = World->GetAuthGameMode<ABasketBallGameGameMode>())\n\t\t{\n\t\t\tGM->RegisterShotAttempt();\n\t\t}\n\t}\n\n\t// Reset charging\n\tbIsCharging = false;\n\tCurrentCharge = 0.0f;\n\n\tClearTrajectoryPreview();\n}\n\n// ======== Trajectory Preview ========\n\nTArray<FVector> UBallHandlerComponent::CalculateTrajectoryPoints(const FVector& StartPos, const FVector& LaunchVelocity) const\n{\n\tTArray<FVector> Points;\n\tPoints.Reserve(TrajectoryPointCount);\n\n\t// Gravity (UE default is -980 cm/s^2)\n\tconst float Gravity = GetWorld()->GetGravityZ(); // Typically -980\n\n\tfor (int32 i = 0; i < TrajectoryPointCount; i++)\n\t{\n\t\tfloat Time = i * TrajectoryTimeStep;\n\n\t\t// Physics projectile formula: P = P0 + V*t + 0.5*g*t^2\n\t\tFVector Point = StartPos\n\t\t\t+ LaunchVelocity * Time\n\t\t\t+ FVector(0.0f, 0.0f, 0.5f * Gravity * Time * Time);\n\n\t\tPoints.Add(Point);\n\n\t\t// Stop if point goes below start position (ball hit the ground)\n\t\tif (i > 5 && Point.Z < StartPos.Z - 200.0f)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn Points;\n}\n\nvoid UBallHandlerComponent::UpdateTrajectoryPreview()\n{\n\tif (!HasBall() || !CurrentBall)\n\t{\n\t\treturn;\n\t}\n\n\t// Get ball position as start of trajectory\n\tFVector StartPos = CurrentBall->GetActorLocation();\n\n\t// Get current launch velocity based on charge\n\tFVector LaunchVelocity = CalculateLaunchVelocity();\n\n\tif (LaunchVelocity.IsNearlyZero())\n\t{\n\t\treturn;\n\t}\n\n\t// Calculate trajectory points\n\tCachedTrajectoryPoints = CalculateTrajectoryPoints(StartPos, LaunchVelocity);\n\n\t// Draw debug lines for trajectory\n\tUWorld* World = GetWorld();\n\tif (!World)\n\t{\n\t\treturn;\n\t}\n\n\tfor (int32 i = 0; i < CachedTrajectoryPoints.Num() - 1; i++)\n\t{\n\t\t// Fade color from white to orange along the arc\n\t\tfloat Alpha = 1.0f - (float(i) / float(CachedTrajectoryPoints.Num()));\n\t\tFColor LineColor = FColor(\n\t\t\t255,\n\t\t\tFMath::Lerp(165, 255, Alpha), // Orange to yellow\n\t\t\tFMath::Lerp(0, 100, Alpha),\n\t\t\tFMath::Clamp(int32(Alpha * 255), 50, 255)\n\t\t);\n\n\t\tDrawDebugLine(\n\t\t\tWorld,\n\t\t\tCachedTrajectoryPoints[i],\n\t\t\tCachedTrajectoryPoints[i + 1],\n\t\t\tLineColor,\n\t\t\tfalse,   // persistent\n\t\t\t0.0f,    // lifetime (0 = one frame)\n\t\t\t0,       // depth priority\n\t\t\t2.0f     // line thickness\n\t\t);\n\t}\n\n\t// Draw small sphere at predicted landing\n\tif (CachedTrajectoryPoints.Num() > 0)\n\t{\n\t\tDrawDebugSphere(\n\t\t\tWorld,\n\t\t\tCachedTrajectoryPoints.Last(),\n\t\t\t12.0f,   // radius\n\t\t\t8,       // segments\n\t\t\tFColor::Orange,\n\t\t\tfalse,\n\t\t\t0.0f     // one frame\n\t\t);\n\t}\n}\n\nvoid UBallHandlerComponent::ClearTrajectoryPreview()\n{\n\tCachedTrajectoryPoints.Empty();\n\t// Debug lines with 0 lifetime auto-clear on next frame\n}\n"}