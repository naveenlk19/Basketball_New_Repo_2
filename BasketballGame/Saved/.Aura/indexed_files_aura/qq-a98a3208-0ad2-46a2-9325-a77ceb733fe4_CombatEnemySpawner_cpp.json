{"file_path": "Source/BasketBallGame/Variant_Combat/AI/CombatEnemySpawner.cpp", "file_id": "Source_BasketBallGame_Variant_Combat_AI_CombatEnemySpawner_cpp", "asset_path": "", "doc_id": "qq-a98a3208-0ad2-46a2-9325-a77ceb733fe4", "referencers": [], "dependencies": [], "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n\n#include \"CombatEnemySpawner.h\"\n#include \"Components/SceneComponent.h\"\n#include \"Components/CapsuleComponent.h\"\n#include \"Components/ArrowComponent.h\"\n#include \"TimerManager.h\"\n#include \"CombatEnemy.h\"\n\nACombatEnemySpawner::ACombatEnemySpawner()\n{\n\tPrimaryActorTick.bCanEverTick = false;\n\n\t// create the root\n\tRootComponent = CreateDefaultSubobject<USceneComponent>(TEXT(\"Root\"));\n\n\t// create the reference spawn capsule\n\tSpawnCapsule = CreateDefaultSubobject<UCapsuleComponent>(TEXT(\"Spawn Capsule\"));\n\tSpawnCapsule->SetupAttachment(RootComponent);\n\n\tSpawnCapsule->SetRelativeLocation(FVector(0.0f, 0.0f, 90.0f));\n\tSpawnCapsule->SetCapsuleSize(35.0f, 90.0f);\n\tSpawnCapsule->SetCollisionProfileName(FName(\"NoCollision\"));\n\n\tSpawnDirection = CreateDefaultSubobject<UArrowComponent>(TEXT(\"Spawn Direction\"));\n\tSpawnDirection->SetupAttachment(RootComponent);\n}\n\nvoid ACombatEnemySpawner::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n\t// should we spawn an enemy right away?\n\tif (bShouldSpawnEnemiesImmediately)\n\t{\n\t\t// schedule the first enemy spawn\n\t\tGetWorld()->GetTimerManager().SetTimer(SpawnTimer, this, &ACombatEnemySpawner::SpawnEnemy, InitialSpawnDelay);\n\t}\n\n}\n\nvoid ACombatEnemySpawner::EndPlay(EEndPlayReason::Type EndPlayReason)\n{\n\tSuper::EndPlay(EndPlayReason);\n\n\t// clear the spawn timer\n\tGetWorld()->GetTimerManager().ClearTimer(SpawnTimer);\n}\n\nvoid ACombatEnemySpawner::SpawnEnemy()\n{\n\t// ensure the enemy class is valid\n\tif (IsValid(EnemyClass))\n\t{\n\t\t// spawn the enemy at the reference capsule's transform\n\t\tFActorSpawnParameters SpawnParams;\n\t\tSpawnParams.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AdjustIfPossibleButAlwaysSpawn;\n\n\t\tACombatEnemy* SpawnedEnemy = GetWorld()->SpawnActor<ACombatEnemy>(EnemyClass, SpawnCapsule->GetComponentTransform(), SpawnParams);\n\n\t\t// was the enemy successfully created?\n\t\tif (SpawnedEnemy)\n\t\t{\n\t\t\t// subscribe to the death delegate\n\t\t\tSpawnedEnemy->OnEnemyDied.AddDynamic(this, &ACombatEnemySpawner::OnEnemyDied);\n\t\t}\n\t}\n}\n\nvoid ACombatEnemySpawner::OnEnemyDied()\n{\n\t// decrease the spawn counter\n\t--SpawnCount;\n\n\t// is this the last enemy we should spawn?\n\tif (SpawnCount <= 0)\n\t{\n\t\t// schedule the activation on depleted message\n\t\tGetWorld()->GetTimerManager().SetTimer(SpawnTimer, this, &ACombatEnemySpawner::SpawnerDepleted, ActivationDelay);\n\t\treturn;\n\t}\n\n\t// schedule the next enemy spawn\n\tGetWorld()->GetTimerManager().SetTimer(SpawnTimer, this, &ACombatEnemySpawner::SpawnEnemy, RespawnDelay);\n}\n\nvoid ACombatEnemySpawner::SpawnerDepleted()\n{\n\t// process the actors to activate list\n\tfor (AActor* CurrentActor : ActorsToActivateWhenDepleted)\n\t{\n\t\t// check if the actor is activatable\n\t\tif (ICombatActivatable* CombatActivatable = Cast<ICombatActivatable>(CurrentActor))\n\t\t{\n\t\t\t// activate the actor\n\t\t\tCombatActivatable->ActivateInteraction(this);\n\t\t}\n\t}\n}\n\nvoid ACombatEnemySpawner::ToggleInteraction(AActor* ActivationInstigator)\n{\n\t// stub\n}\n\nvoid ACombatEnemySpawner::ActivateInteraction(AActor* ActivationInstigator)\n{\n\t// ensure we're only activated once, and only if we've deferred enemy spawning\n\tif (bHasBeenActivated || bShouldSpawnEnemiesImmediately)\n\t{\n\t\treturn;\n\t}\n\n\t// raise the activation flag\n\tbHasBeenActivated = true;\n\n\t// spawn the first enemy\n\tSpawnEnemy();\n}\n\nvoid ACombatEnemySpawner::DeactivateInteraction(AActor* ActivationInstigator)\n{\n\t// stub\n}\n"}