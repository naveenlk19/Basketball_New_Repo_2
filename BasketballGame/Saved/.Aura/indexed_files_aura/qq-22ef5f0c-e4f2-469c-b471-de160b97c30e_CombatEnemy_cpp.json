{"file_path": "Source/BasketBallGame/Variant_Combat/AI/CombatEnemy.cpp", "file_id": "Source_BasketBallGame_Variant_Combat_AI_CombatEnemy_cpp", "asset_path": "", "doc_id": "qq-22ef5f0c-e4f2-469c-b471-de160b97c30e", "referencers": [], "dependencies": [], "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n\n#include \"CombatEnemy.h\"\n#include \"Components/CapsuleComponent.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"CombatAIController.h\"\n#include \"Components/WidgetComponent.h\"\n#include \"Engine/DamageEvents.h\"\n#include \"CombatLifeBar.h\"\n#include \"TimerManager.h\"\n#include \"Components/SkeletalMeshComponent.h\"\n#include \"Animation/AnimInstance.h\"\n\nACombatEnemy::ACombatEnemy()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// bind the attack montage ended delegate\n\tOnAttackMontageEnded.BindUObject(this, &ACombatEnemy::AttackMontageEnded);\n\n\t// set the AI Controller class by default\n\tAIControllerClass = ACombatAIController::StaticClass();\n\n\t// use an AI Controller regardless of whether we're placed or spawned\n\tAutoPossessAI = EAutoPossessAI::PlacedInWorldOrSpawned;\n\n\t// ignore the controller's yaw rotation\n\tbUseControllerRotationYaw = false;\n\n\t// create the life bar\n\tLifeBar = CreateDefaultSubobject<UWidgetComponent>(TEXT(\"LifeBar\"));\n\tLifeBar->SetupAttachment(RootComponent);\n\n\t// set the collision capsule size\n\tGetCapsuleComponent()->SetCapsuleSize(35.0f, 90.0f);\n\n\t// set the character movement properties\n\tGetCharacterMovement()->bUseControllerDesiredRotation = true;\n\n\t// reset HP to maximum\n\tCurrentHP = MaxHP;\n}\n\nvoid ACombatEnemy::DoAIComboAttack()\n{\n\t// ignore if we're already playing an attack animation\n\tif (bIsAttacking)\n\t{\n\t\treturn;\n\t}\n\n\t// raise the attacking flag\n\tbIsAttacking = true;\n\n\t// choose how many times we're going to attack\n\tTargetComboCount = FMath::RandRange(1, ComboSectionNames.Num() - 1);\n\n\t// reset the attack counter\n\tCurrentComboAttack = 0;\n\n\t// play the attack montage\n\tif (UAnimInstance* AnimInstance = GetMesh()->GetAnimInstance())\n\t{\n\t\tconst float MontageLength = AnimInstance->Montage_Play(ComboAttackMontage, 1.0f, EMontagePlayReturnType::MontageLength, 0.0f, true);\n\n\t\t// subscribe to montage completed and interrupted events\n\t\tif (MontageLength > 0.0f)\n\t\t{\n\t\t\t// set the end delegate for the montage\n\t\t\tAnimInstance->Montage_SetEndDelegate(OnAttackMontageEnded, ComboAttackMontage);\n\t\t}\n\t}\n}\n\nvoid ACombatEnemy::DoAIChargedAttack()\n{\n\t// ignore if we're already playing an attack animation\n\tif (bIsAttacking)\n\t{\n\t\treturn;\n\t}\n\n\t// raise the attacking flag\n\tbIsAttacking = true;\n\n\t// choose how many loops are we going to charge for\n\tTargetChargeLoops = FMath::RandRange(MinChargeLoops, MaxChargeLoops);\n\n\t// reset the charge loop counter\n\tCurrentChargeLoop = 0;\n\n\t// play the attack montage\n\tif (UAnimInstance* AnimInstance = GetMesh()->GetAnimInstance())\n\t{\n\t\tconst float MontageLength = AnimInstance->Montage_Play(ChargedAttackMontage, 1.0f, EMontagePlayReturnType::MontageLength, 0.0f, true);\n\n\t\t// subscribe to montage completed and interrupted events\n\t\tif (MontageLength > 0.0f)\n\t\t{\n\t\t\t// set the end delegate for the montage\n\t\t\tAnimInstance->Montage_SetEndDelegate(OnAttackMontageEnded, ChargedAttackMontage);\n\t\t}\n\t}\n}\n\nvoid ACombatEnemy::AttackMontageEnded(UAnimMontage* Montage, bool bInterrupted)\n{\n\t// reset the attacking flag\n\tbIsAttacking = false;\n\n\t// call the attack completed delegate so the StateTree can continue execution\n\tOnAttackCompleted.ExecuteIfBound();\n}\n\nvoid ACombatEnemy::DoAttackTrace(FName DamageSourceBone)\n{\n\t// sweep for objects in front of the character to be hit by the attack\n\tTArray<FHitResult> OutHits;\n\n\t// start at the provided socket location, sweep forward\n\tconst FVector TraceStart = GetMesh()->GetSocketLocation(DamageSourceBone);\n\tconst FVector TraceEnd = TraceStart + (GetActorForwardVector() * MeleeTraceDistance);\n\n\t// enemies only affect Pawn collision objects; they don't knock back boxes\n\tFCollisionObjectQueryParams ObjectParams;\n\tObjectParams.AddObjectTypesToQuery(ECC_Pawn);\n\n\t// use a sphere shape for the sweep\n\tFCollisionShape CollisionShape;\n\tCollisionShape.SetSphere(MeleeTraceRadius);\n\n\t// ignore self\n\tFCollisionQueryParams QueryParams;\n\tQueryParams.AddIgnoredActor(this);\n\n\tif (GetWorld()->SweepMultiByObjectType(OutHits, TraceStart, TraceEnd, FQuat::Identity, ObjectParams, CollisionShape, QueryParams))\n\t{\n\t\t// iterate over each object hit\n\t\tfor (const FHitResult& CurrentHit : OutHits)\n\t\t{\n\t\t\t/** does the actor have the player tag? */\n\t\t\tif (CurrentHit.GetActor()->ActorHasTag(FName(\"Player\")))\n\t\t\t{\n\t\t\t\t// check if the actor is damageable\n\t\t\t\tICombatDamageable* Damageable = Cast<ICombatDamageable>(CurrentHit.GetActor());\n\n\t\t\t\tif (Damageable)\n\t\t\t\t{\n\t\t\t\t\t// knock upwards and away from the impact normal\n\t\t\t\t\tconst FVector Impulse = (CurrentHit.ImpactNormal * -MeleeKnockbackImpulse) + (FVector::UpVector * MeleeLaunchImpulse);\n\n\t\t\t\t\t// pass the damage event to the actor\n\t\t\t\t\tDamageable->ApplyDamage(MeleeDamage, this, CurrentHit.ImpactPoint, Impulse);\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid ACombatEnemy::CheckCombo()\n{\n\t// increase the combo counter\n\t++CurrentComboAttack;\n\n\t// do we still have attacks to play in this string?\n\tif (CurrentComboAttack < TargetComboCount)\n\t{\n\t\t// jump to the next attack section\n\t\tif (UAnimInstance* AnimInstance = GetMesh()->GetAnimInstance())\n\t\t{\n\t\t\tAnimInstance->Montage_JumpToSection(ComboSectionNames[CurrentComboAttack], ComboAttackMontage);\n\t\t}\n\t}\n}\n\nvoid ACombatEnemy::CheckChargedAttack()\n{\n\t// increase the charge loop counter\n\t++CurrentChargeLoop;\n\n\t// jump to either the loop or attack section of the montage depending on whether we hit the loop target\n\tif (UAnimInstance* AnimInstance = GetMesh()->GetAnimInstance())\n\t{\n\t\tAnimInstance->Montage_JumpToSection(CurrentChargeLoop >= TargetChargeLoops ? ChargeAttackSection : ChargeLoopSection, ChargedAttackMontage);\n\t}\n}\n\nvoid ACombatEnemy::ApplyDamage(float Damage, AActor* DamageCauser, const FVector& DamageLocation, const FVector& DamageImpulse)\n{\n\t\n\t// pass the damage event to the actor\n\tFDamageEvent DamageEvent;\n\tconst float ActualDamage = TakeDamage(Damage, DamageEvent, nullptr, DamageCauser);\n\n\t// only process knockback and effects if we received nonzero damage\n\tif (ActualDamage > 0.0f)\n\t{\n\t\t// apply the knockback impulse\n\t\tGetCharacterMovement()->AddImpulse(DamageImpulse, true);\n\n\t\t// is the character ragdolling?\n\t\tif (GetMesh()->IsSimulatingPhysics())\n\t\t{\n\t\t\t// apply an impulse to the ragdoll\n\t\t\tGetMesh()->AddImpulseAtLocation(DamageImpulse * GetMesh()->GetMass(), DamageLocation);\n\t\t}\n\n\t\t// stop the attack montages to interrupt the attack\n\t\tif (UAnimInstance* AnimInstance = GetMesh()->GetAnimInstance())\n\t\t{\n\t\t\tAnimInstance->Montage_Stop(0.1f, ComboAttackMontage);\n\t\t\tAnimInstance->Montage_Stop(0.1f, ChargedAttackMontage);\n\t\t}\n\n\t\t// pass control to BP to play effects, etc.\n\t\tReceivedDamage(ActualDamage, DamageLocation, DamageImpulse.GetSafeNormal());\n\t}\n}\n\nvoid ACombatEnemy::HandleDeath()\n{\n\t// hide the life bar\n\tLifeBar->SetHiddenInGame(true);\n\n\t// disable the collision capsule to avoid being hit again while dead\n\tGetCapsuleComponent()->SetCollisionEnabled(ECollisionEnabled::NoCollision);\n\n\t// disable character movement\n\tGetCharacterMovement()->DisableMovement();\n\n\t// enable full ragdoll physics\n\tGetMesh()->SetSimulatePhysics(true);\n\n\t// call the died delegate to notify any subscribers\n\tOnEnemyDied.Broadcast();\n\n\t// set up the death timer\n\tGetWorld()->GetTimerManager().SetTimer(DeathTimer, this, &ACombatEnemy::RemoveFromLevel, DeathRemovalTime);\n}\n\nvoid ACombatEnemy::ApplyHealing(float Healing, AActor* Healer)\n{\n\t// stub\n}\n\nvoid ACombatEnemy::RemoveFromLevel()\n{\n\t// destroy this actor\n\tDestroy();\n}\n\nfloat ACombatEnemy::TakeDamage(float Damage, struct FDamageEvent const& DamageEvent, AController* EventInstigator, AActor* DamageCauser)\n{\n\t// only process damage if the character is still alive\n\tif (CurrentHP <= 0.0f)\n\t{\n\t\treturn 0.0f;\n\t}\n\n\t// reduce the current HP\n\tCurrentHP -= Damage;\n\n\t// have we run out of HP?\n\tif (CurrentHP <= 0.0f)\n\t{\n\t\t// die\n\t\tHandleDeath();\n\t}\n\telse\n\t{\n\t\t// update the life bar\n\t\tLifeBarWidget->SetLifePercentage(CurrentHP / MaxHP);\n\n\t\t// enable partial ragdoll physics, but keep the pelvis vertical\n\t\tGetMesh()->SetPhysicsBlendWeight(0.5f);\n\t\tGetMesh()->SetBodySimulatePhysics(PelvisBoneName, false);\n\t}\n\n\t// return the received damage amount\n\treturn Damage;\n}\n\nvoid ACombatEnemy::Landed(const FHitResult& Hit)\n{\n\tSuper::Landed(Hit);\n\n\t// is the character still alive?\n\tif (CurrentHP >= 0.0f)\n\t{\n\t\t// disable ragdoll physics\n\t\tGetMesh()->SetPhysicsBlendWeight(0.0f);\n\t}\n\n\t// call the landed Delegate for StateTree\n\tOnEnemyLanded.ExecuteIfBound();\n}\n\nvoid ACombatEnemy::BeginPlay()\n{\n\t// reset HP to maximum\n\tCurrentHP = MaxHP;\n\n\t// we top the HP before BeginPlay so StateTree picks it up at the right value\n\tSuper::BeginPlay();\n\n\t// get the life bar widget from the widget comp\n\tLifeBarWidget = Cast<UCombatLifeBar>(LifeBar->GetUserWidgetObject());\n\tcheck(LifeBarWidget);\n\n\t// fill the life bar\n\tLifeBarWidget->SetLifePercentage(1.0f);\n}\n\nvoid ACombatEnemy::EndPlay(EEndPlayReason::Type EndPlayReason)\n{\n\tSuper::EndPlay(EndPlayReason);\n\n\t// clear the death timer\n\tGetWorld()->GetTimerManager().ClearTimer(DeathTimer);\n}\n"}