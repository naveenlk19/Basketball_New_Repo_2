{"file_path": "Source/BasketBallGame/Variant_Platforming/PlatformingCharacter.cpp", "file_id": "Source_BasketBallGame_Variant_Platforming_PlatformingCharacter_cpp", "asset_path": "", "doc_id": "qq-c1adb4ae-bbc0-4ba0-9217-7ed6f43c817f", "referencers": [], "dependencies": [], "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n\n#include \"PlatformingCharacter.h\"\n\n#include \"Components/CapsuleComponent.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"GameFramework/SpringArmComponent.h\"\n#include \"Components/SkeletalMeshComponent.h\"\n#include \"Camera/CameraComponent.h\"\n#include \"EnhancedInputSubsystems.h\"\n#include \"EnhancedInputComponent.h\"\n#include \"TimerManager.h\"\n#include \"Engine/LocalPlayer.h\"\n\nAPlatformingCharacter::APlatformingCharacter()\n{\n \tPrimaryActorTick.bCanEverTick = true;\n\n\t// initialize the flags\n\tbHasWallJumped = false;\n\tbHasDoubleJumped = false;\n\tbHasDashed = false;\n\tbIsDashing = false;\n\n\t// bind the attack montage ended delegate\n\tOnDashMontageEnded.BindUObject(this, &APlatformingCharacter::DashMontageEnded);\n\n\t// enable press and hold jump\n\tJumpMaxHoldTime = 0.4f;\n\n\t// set the jump max count to 3 so we can double jump and check for coyote time jumps\n\tJumpMaxCount = 3;\n\n\t// Set size for collision capsule\n\tGetCapsuleComponent()->InitCapsuleSize(35.0f, 90.0f);\n\n\t// don't rotate the mesh when the controller rotates\n\tbUseControllerRotationYaw = false;\n\t\n\t// Configure character movement\n\tGetCharacterMovement()->GravityScale = 2.5f;\n\tGetCharacterMovement()->MaxAcceleration = 1500.0f;\n\tGetCharacterMovement()->BrakingFrictionFactor = 1.0f;\n\tGetCharacterMovement()->bUseSeparateBrakingFriction = true;\n\n\tGetCharacterMovement()->GroundFriction = 4.0f;\n\tGetCharacterMovement()->MaxWalkSpeed = 750.0f;\n\tGetCharacterMovement()->MinAnalogWalkSpeed = 20.0f;\n\tGetCharacterMovement()->BrakingDecelerationWalking = 2500.0f;\n\tGetCharacterMovement()->PerchRadiusThreshold = 15.0f;\n\n\tGetCharacterMovement()->JumpZVelocity = 350.0f;\n\tGetCharacterMovement()->BrakingDecelerationFalling = 750.0f;\n\tGetCharacterMovement()->AirControl = 1.0f;\n\n\tGetCharacterMovement()->RotationRate = FRotator(0.0f, 500.0f, 0.0f);\n\tGetCharacterMovement()->bOrientRotationToMovement = true;\n\n\tGetCharacterMovement()->NavAgentProps.AgentRadius = 42.0;\n\tGetCharacterMovement()->NavAgentProps.AgentHeight = 192.0;\n\n\t// create the camera boom\n\tCameraBoom = CreateDefaultSubobject<USpringArmComponent>(TEXT(\"CameraBoom\"));\n\tCameraBoom->SetupAttachment(RootComponent);\n\n\tCameraBoom->TargetArmLength = 400.0f;\n\tCameraBoom->bUsePawnControlRotation = true;\n\tCameraBoom->bEnableCameraLag = true;\n\tCameraBoom->CameraLagSpeed = 8.0f;\n\tCameraBoom->bEnableCameraRotationLag = true;\t\n\tCameraBoom->CameraRotationLagSpeed = 8.0f;\n\n\t// create the orbiting camera\n\tFollowCamera = CreateDefaultSubobject<UCameraComponent>(TEXT(\"FollowCamera\"));\n\tFollowCamera->SetupAttachment(CameraBoom, USpringArmComponent::SocketName);\n\tFollowCamera->bUsePawnControlRotation = false;\n}\n\nvoid APlatformingCharacter::Move(const FInputActionValue& Value)\n{\n\tFVector2D MovementVector = Value.Get<FVector2D>();\n\n\t// route the input\n\tDoMove(MovementVector.X, MovementVector.Y);\n}\n\nvoid APlatformingCharacter::Look(const FInputActionValue& Value)\n{\n\tFVector2D LookAxisVector = Value.Get<FVector2D>();\n\n\t// route the input\n\tDoLook(LookAxisVector.X, LookAxisVector.Y);\n}\n\n\nvoid APlatformingCharacter::Dash()\n{\n\t// route the input\n\tDoDash();\n}\n\nvoid APlatformingCharacter::MultiJump()\n{\n\t// ignore jumps while dashing\n\tif(bIsDashing)\n\t\treturn;\n\n\t// are we already in the air?\n\tif (GetCharacterMovement()->IsFalling())\n\t{\n\n\t\t// have we already wall jumped?\n\t\tif (!bHasWallJumped)\n\t\t{\n\t\t\t// run a sphere sweep to check if we're in front of a wall\n\t\t\tFHitResult OutHit;\n\n\t\t\tconst FVector TraceStart = GetActorLocation();\n\t\t\tconst FVector TraceEnd = TraceStart + (GetActorForwardVector() * WallJumpTraceDistance);\n\t\t\tconst FCollisionShape TraceShape = FCollisionShape::MakeSphere(WallJumpTraceRadius);\n\n\t\t\tFCollisionQueryParams QueryParams;\n\t\t\tQueryParams.AddIgnoredActor(this);\n\n\t\t\tif (GetWorld()->SweepSingleByChannel(OutHit, TraceStart, TraceEnd, FQuat(), ECollisionChannel::ECC_Visibility, TraceShape, QueryParams))\n\t\t\t{\n\t\t\t\t// rotate the character to face away from the wall, so we're correctly oriented for the next wall jump\n\t\t\t\tFRotator WallOrientation = OutHit.ImpactNormal.ToOrientationRotator();\n\t\t\t\tWallOrientation.Pitch = 0.0f;\n\t\t\t\tWallOrientation.Roll = 0.0f;\n\n\t\t\t\tSetActorRotation(WallOrientation);\n\n\t\t\t\t// apply a launch impulse to the character to perform the actual wall jump\n\t\t\t\tconst FVector WallJumpImpulse = (OutHit.ImpactNormal * WallJumpBounceImpulse) + (FVector::UpVector * WallJumpVerticalImpulse);\n\n\t\t\t\tLaunchCharacter(WallJumpImpulse, true, true);\n\n\t\t\t\t// enable the jump trail\n\t\t\t\tSetJumpTrailState(true);\n\n\t\t\t\t// raise the wall jump flag to prevent an immediate second wall jump\n\t\t\t\tbHasWallJumped = true;\n\n\t\t\t\tGetWorld()->GetTimerManager().SetTimer(WallJumpTimer, this, &APlatformingCharacter::ResetWallJump, DelayBetweenWallJumps, false);\n\t\t\t}\n\t\t\t// no wall jump, try a double jump next\n\t\t\telse\n\t\t\t{\n\t\t\t\t// are we still within coyote time frames?\n\t\t\t\tif (GetWorld()->GetTimeSeconds() - LastFallTime < MaxCoyoteTime)\n\t\t\t\t{\n\t\t\t\t\tUE_LOG(LogTemp, Warning, TEXT(\"Coyote Jump\"));\n\n\t\t\t\t\t// use the built-in CMC functionality to do the jump\n\t\t\t\t\tJump();\n\n\t\t\t\t\t// enable the jump trail\n\t\t\t\t\tSetJumpTrailState(true);\n\n\t\t\t\t// no coyote time jump\n\t\t\t\t} else {\n\n\t\t\t\t\t// only double jump once while we're in the air\n\t\t\t\t\tif (!bHasDoubleJumped)\n\t\t\t\t\t{\n\t\t\t\t\t\tbHasDoubleJumped = true;\n\n\t\t\t\t\t\t// use the built-in CMC functionality to do the double jump\n\t\t\t\t\t\tJump();\n\n\t\t\t\t\t\t// enable the jump trail\n\t\t\t\t\t\tSetJumpTrailState(true);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t\n\t\t\t}\n\t\t}\n\n\t}\n\telse\n\t{\n\t\t// we're grounded so just do a regular jump\n\t\tJump();\n\n\t\t// activate the jump trail\n\t\tSetJumpTrailState(true);\n\t}\n}\n\nvoid APlatformingCharacter::ResetWallJump()\n{\n\t// reset the wall jump input lock\n\tbHasWallJumped = false;\n}\n\nvoid APlatformingCharacter::DoMove(float Right, float Forward)\n{\n\tif (GetController() != nullptr)\n\t{\n\t\t// momentarily disable movement inputs if we've just wall jumped\n\t\tif (!bHasWallJumped)\n\t\t{\n\t\t\t// find out which way is forward\n\t\t\tconst FRotator Rotation = GetController()->GetControlRotation();\n\t\t\tconst FRotator YawRotation(0, Rotation.Yaw, 0);\n\n\t\t\t// get forward vector\n\t\t\tconst FVector ForwardDirection = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::X);\n\n\t\t\t// get right vector \n\t\t\tconst FVector RightDirection = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::Y);\n\n\t\t\t// add movement \n\t\t\tAddMovementInput(ForwardDirection, Forward);\n\t\t\tAddMovementInput(RightDirection, Right);\n\t\t}\n\t}\n}\n\nvoid APlatformingCharacter::DoLook(float Yaw, float Pitch)\n{\n\tif (GetController() != nullptr)\n\t{\n\t\t// add yaw and pitch input to controller\n\t\tAddControllerYawInput(Yaw);\n\t\tAddControllerPitchInput(Pitch);\n\t}\n}\n\nvoid APlatformingCharacter::DoDash()\n{\n\t// ignore the input if we've already dashed and have yet to reset\n\tif (bHasDashed)\n\t\treturn;\n\n\t// raise the dash flags\n\tbIsDashing = true;\n\tbHasDashed = true;\n\n\t// disable gravity while dashing\n\tGetCharacterMovement()->GravityScale = 0.0f;\n\n\t// reset the character velocity so we don't carry momentum into the dash\n\tGetCharacterMovement()->Velocity = FVector::ZeroVector;\n\n\t// enable the jump trails\n\tSetJumpTrailState(true);\n\n\t// play the dash montage\n\tif (UAnimInstance* AnimInstance = GetMesh()->GetAnimInstance())\n\t{\n\t\tconst float MontageLength = AnimInstance->Montage_Play(DashMontage, 1.0f, EMontagePlayReturnType::MontageLength, 0.0f, true);\n\n\t\t// has the montage played successfully?\n\t\tif (MontageLength > 0.0f)\n\t\t{\n\t\t\tAnimInstance->Montage_SetEndDelegate(OnDashMontageEnded, DashMontage);\n\t\t}\n\t}\n}\n\nvoid APlatformingCharacter::DoJumpStart()\n{\n\t// handle special jump cases\n\tMultiJump();\n}\n\nvoid APlatformingCharacter::DoJumpEnd()\n{\n\t// stop jumping\n\tStopJumping();\n}\n\nvoid APlatformingCharacter::DashMontageEnded(UAnimMontage* Montage, bool bInterrupted)\n{\n\t// if the montage was interrupted, end the dash\n\tif (bInterrupted)\n\t{\n\t\tEndDash();\n\t}\n}\n\nvoid APlatformingCharacter::EndDash()\n{\n\t// restore gravity\n\tGetCharacterMovement()->GravityScale = 2.5f;\n\n\t// reset the dashing flag\n\tbIsDashing = false;\n\n\t// are we grounded after the dash?\n\tif (GetCharacterMovement()->IsMovingOnGround())\n\t{\n\t\t// reset the dash usage flag, since we won't receive a landed event\n\t\tbHasDashed = false;\n\n\t\t// deactivate the jump trails\n\t\tSetJumpTrailState(false);\n\t}\n}\n\nbool APlatformingCharacter::HasDoubleJumped() const\n{\n\treturn bHasDoubleJumped;\n}\n\nbool APlatformingCharacter::HasWallJumped() const\n{\n\treturn bHasWallJumped;\n}\n\nvoid APlatformingCharacter::EndPlay(const EEndPlayReason::Type EndPlayReason)\n{\n\tSuper::EndPlay(EndPlayReason);\n\n\t// clear the wall jump reset timer\n\tGetWorld()->GetTimerManager().ClearTimer(WallJumpTimer);\n}\n\nvoid APlatformingCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\t// Set up action bindings\n\tif (UEnhancedInputComponent* EnhancedInputComponent = Cast<UEnhancedInputComponent>(PlayerInputComponent))\n\t{\n\n\t\t// Jumping\n\t\tEnhancedInputComponent->BindAction(JumpAction, ETriggerEvent::Started, this, &APlatformingCharacter::DoJumpStart);\n\t\tEnhancedInputComponent->BindAction(JumpAction, ETriggerEvent::Completed, this, &APlatformingCharacter::DoJumpEnd);\n\n\t\t// Moving\n\t\tEnhancedInputComponent->BindAction(MoveAction, ETriggerEvent::Triggered, this, &APlatformingCharacter::Move);\n\t\tEnhancedInputComponent->BindAction(MouseLookAction, ETriggerEvent::Triggered, this, &APlatformingCharacter::Look);\n\n\t\t// Looking\n\t\tEnhancedInputComponent->BindAction(LookAction, ETriggerEvent::Triggered, this, &APlatformingCharacter::Look);\n\n\t\t// Dashing\n\t\tEnhancedInputComponent->BindAction(DashAction, ETriggerEvent::Triggered, this, &APlatformingCharacter::Dash);\n\t}\n}\n\nvoid APlatformingCharacter::Landed(const FHitResult& Hit)\n{\n\tSuper::Landed(Hit);\n\n\t// reset the double jump and dash flags\n\tbHasDoubleJumped = false;\n\tbHasDashed = false;\n\n\t// deactivate the jump trail\n\tSetJumpTrailState(false);\n}\n\nvoid APlatformingCharacter::OnMovementModeChanged(EMovementMode PrevMovementMode, uint8 PreviousCustomMode /*= 0*/)\n{\n\tSuper::OnMovementModeChanged(PrevMovementMode, PreviousCustomMode);\n\n\t// are we falling?\n\tif (GetCharacterMovement()->MovementMode == EMovementMode::MOVE_Falling)\n\t{\n\t\t// save the game time when we started falling, so we can check it later for coyote time jumps\n\t\tLastFallTime = GetWorld()->GetTimeSeconds();\n\t}\n}\n\n"}