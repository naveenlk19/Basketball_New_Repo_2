{"file_path": "Source/BasketBallGame/Variant_Combat/CombatCharacter.cpp", "file_id": "Source_BasketBallGame_Variant_Combat_CombatCharacter_cpp", "asset_path": "", "doc_id": "qq-b26ca5e3-1185-40ea-9be5-d82e46c69fba", "referencers": [], "dependencies": [], "content": "// Copyright Epic Games, Inc. All Rights Reserved.\n\n\n#include \"CombatCharacter.h\"\n#include \"Components/CapsuleComponent.h\"\n#include \"Components/WidgetComponent.h\"\n#include \"GameFramework/CharacterMovementComponent.h\"\n#include \"GameFramework/SpringArmComponent.h\"\n#include \"Components/SkeletalMeshComponent.h\"\n#include \"Camera/CameraComponent.h\"\n#include \"EnhancedInputSubsystems.h\"\n#include \"EnhancedInputComponent.h\"\n#include \"CombatLifeBar.h\"\n#include \"Engine/DamageEvents.h\"\n#include \"TimerManager.h\"\n#include \"Engine/LocalPlayer.h\"\n#include \"CombatPlayerController.h\"\n\nACombatCharacter::ACombatCharacter()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n\n\t// bind the attack montage ended delegate\n\tOnAttackMontageEnded.BindUObject(this, &ACombatCharacter::AttackMontageEnded);\n\n\t// Set size for collision capsule\n\tGetCapsuleComponent()->InitCapsuleSize(35.0f, 90.0f);\n\n\t// Configure character movement\n\tGetCharacterMovement()->MaxWalkSpeed = 400.0f;\n\n\t// create the camera boom\n\tCameraBoom = CreateDefaultSubobject<USpringArmComponent>(TEXT(\"CameraBoom\"));\n\tCameraBoom->SetupAttachment(RootComponent);\n\n\tCameraBoom->TargetArmLength = DefaultCameraDistance;\n\tCameraBoom->bUsePawnControlRotation = true;\n\tCameraBoom->bEnableCameraLag = true;\n\tCameraBoom->bEnableCameraRotationLag = true;\n\n\t// create the orbiting camera\n\tFollowCamera = CreateDefaultSubobject<UCameraComponent>(TEXT(\"FollowCamera\"));\n\tFollowCamera->SetupAttachment(CameraBoom, USpringArmComponent::SocketName);\n\tFollowCamera->bUsePawnControlRotation = false;\n\n\t// create the life bar widget component\n\tLifeBar = CreateDefaultSubobject<UWidgetComponent>(TEXT(\"LifeBar\"));\n\tLifeBar->SetupAttachment(RootComponent);\n\n\t// set the player tag\n\tTags.Add(FName(\"Player\"));\n}\n\nvoid ACombatCharacter::Move(const FInputActionValue& Value)\n{\n\t// input is a Vector2D\n\tFVector2D MovementVector = Value.Get<FVector2D>();\n\n\t// route the input\n\tDoMove(MovementVector.X, MovementVector.Y);\n}\n\nvoid ACombatCharacter::Look(const FInputActionValue& Value)\n{\n\tFVector2D LookAxisVector = Value.Get<FVector2D>();\n\n\t// route the input\n\tDoLook(LookAxisVector.X, LookAxisVector.Y);\n}\n\nvoid ACombatCharacter::ComboAttackPressed()\n{\n\t// route the input\n\tDoComboAttackStart();\n}\n\nvoid ACombatCharacter::ChargedAttackPressed()\n{\n\t// route the input\n\tDoChargedAttackStart();\n}\n\nvoid ACombatCharacter::ChargedAttackReleased()\n{\n\t// route the input\n\tDoChargedAttackEnd();\n}\n\nvoid ACombatCharacter::DoMove(float Right, float Forward)\n{\n\tif (GetController() != nullptr)\n\t{\n\t\t// find out which way is forward\n\t\tconst FRotator Rotation = GetController()->GetControlRotation();\n\t\tconst FRotator YawRotation(0, Rotation.Yaw, 0);\n\n\t\t// get forward vector\n\t\tconst FVector ForwardDirection = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::X);\n\n\t\t// get right vector \n\t\tconst FVector RightDirection = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::Y);\n\n\t\t// add movement \n\t\tAddMovementInput(ForwardDirection, Forward);\n\t\tAddMovementInput(RightDirection, Right);\n\t}\n}\n\nvoid ACombatCharacter::DoLook(float Yaw, float Pitch)\n{\n\tif (GetController() != nullptr)\n\t{\n\t\t// add yaw and pitch input to controller\n\t\tAddControllerYawInput(Yaw);\n\t\tAddControllerPitchInput(Pitch);\n\t}\n}\n\nvoid ACombatCharacter::DoComboAttackStart()\n{\n\t// are we already playing an attack animation?\n\tif (bIsAttacking)\n\t{\n\t\t// cache the input time so we can check it later\n\t\tCachedAttackInputTime = GetWorld()->GetTimeSeconds();\n\n\t\treturn;\n\t}\n\n\t// perform a combo attack\n\tComboAttack();\n}\n\nvoid ACombatCharacter::DoComboAttackEnd()\n{\n\t// stub\n}\n\nvoid ACombatCharacter::DoChargedAttackStart()\n{\n\t// raise the charging attack flag\n\tbIsChargingAttack = true;\n\n\tif (bIsAttacking)\n\t{\n\t\t// cache the input time so we can check it later\n\t\tCachedAttackInputTime = GetWorld()->GetTimeSeconds();\n\n\t\treturn;\n\t}\n\n\tChargedAttack();\n}\n\nvoid ACombatCharacter::DoChargedAttackEnd()\n{\n\t// lower the charging attack flag\n\tbIsChargingAttack = false;\n\n\t// if we've done the charge loop at least once, release the charged attack right away\n\tif (bHasLoopedChargedAttack)\n\t{\n\t\tCheckChargedAttack();\n\t}\n}\n\nvoid ACombatCharacter::ResetHP()\n{\n\t// reset the current HP total\n\tCurrentHP = MaxHP;\n\n\t// update the life bar\n\tLifeBarWidget->SetLifePercentage(1.0f);\n}\n\nvoid ACombatCharacter::ComboAttack()\n{\n\t// raise the attacking flag\n\tbIsAttacking = true;\n\n\t// reset the combo count\n\tComboCount = 0;\n\n\t// play the attack montage\n\tif (UAnimInstance* AnimInstance = GetMesh()->GetAnimInstance())\n\t{\n\t\tconst float MontageLength = AnimInstance->Montage_Play(ComboAttackMontage, 1.0f, EMontagePlayReturnType::MontageLength, 0.0f, true);\n\n\t\t// subscribe to montage completed and interrupted events\n\t\tif (MontageLength > 0.0f)\n\t\t{\n\t\t\t// set the end delegate for the montage\n\t\t\tAnimInstance->Montage_SetEndDelegate(OnAttackMontageEnded, ComboAttackMontage);\n\t\t}\n\t}\n\n}\n\nvoid ACombatCharacter::ChargedAttack()\n{\n\t// raise the attacking flag\n\tbIsAttacking = true;\n\n\t// reset the charge loop flag\n\tbHasLoopedChargedAttack = false;\n\n\t// play the charged attack montage\n\tif (UAnimInstance* AnimInstance = GetMesh()->GetAnimInstance())\n\t{\n\t\tconst float MontageLength = AnimInstance->Montage_Play(ChargedAttackMontage, 1.0f, EMontagePlayReturnType::MontageLength, 0.0f, true);\n\n\t\t// subscribe to montage completed and interrupted events\n\t\tif (MontageLength > 0.0f)\n\t\t{\n\t\t\t// set the end delegate for the montage\n\t\t\tAnimInstance->Montage_SetEndDelegate(OnAttackMontageEnded, ChargedAttackMontage);\n\t\t}\n\t}\n}\n\nvoid ACombatCharacter::AttackMontageEnded(UAnimMontage* Montage, bool bInterrupted)\n{\n\t// reset the attacking flag\n\tbIsAttacking = false;\n\n\t// check if we have a non-stale cached input\n\tif (GetWorld()->GetTimeSeconds() - CachedAttackInputTime <= AttackInputCacheTimeTolerance)\n\t{\n\t\t// are we holding the charged attack button?\n\t\tif (bIsChargingAttack)\n\t\t{\n\t\t\t// do a charged attack\n\t\t\tChargedAttack();\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// do a regular attack\n\t\t\tComboAttack();\n\t\t}\n\t}\n}\n\nvoid ACombatCharacter::DoAttackTrace(FName DamageSourceBone)\n{\n\t// sweep for objects in front of the character to be hit by the attack\n\tTArray<FHitResult> OutHits;\n\n\t// start at the provided socket location, sweep forward\n\tconst FVector TraceStart = GetMesh()->GetSocketLocation(DamageSourceBone);\n\tconst FVector TraceEnd = TraceStart + (GetActorForwardVector() * MeleeTraceDistance);\n\n\t// check for pawn and world dynamic collision object types\n\tFCollisionObjectQueryParams ObjectParams;\n\tObjectParams.AddObjectTypesToQuery(ECC_Pawn);\n\tObjectParams.AddObjectTypesToQuery(ECC_WorldDynamic);\n\n\t// use a sphere shape for the sweep\n\tFCollisionShape CollisionShape;\n\tCollisionShape.SetSphere(MeleeTraceRadius);\n\n\t// ignore self\n\tFCollisionQueryParams QueryParams;\n\tQueryParams.AddIgnoredActor(this);\n\n\tif (GetWorld()->SweepMultiByObjectType(OutHits, TraceStart, TraceEnd, FQuat::Identity, ObjectParams, CollisionShape, QueryParams))\n\t{\n\t\t// iterate over each object hit\n\t\tfor (const FHitResult& CurrentHit : OutHits)\n\t\t{\n\t\t\t// check if we've hit a damageable actor\n\t\t\tICombatDamageable* Damageable = Cast<ICombatDamageable>(CurrentHit.GetActor());\n\n\t\t\tif (Damageable)\n\t\t\t{\n\t\t\t\t// knock upwards and away from the impact normal\n\t\t\t\tconst FVector Impulse = (CurrentHit.ImpactNormal * -MeleeKnockbackImpulse) + (FVector::UpVector * MeleeLaunchImpulse);\n\n\t\t\t\t// pass the damage event to the actor\n\t\t\t\tDamageable->ApplyDamage(MeleeDamage, this, CurrentHit.ImpactPoint, Impulse);\n\n\t\t\t\t// call the BP handler to play effects, etc.\n\t\t\t\tDealtDamage(MeleeDamage, CurrentHit.ImpactPoint);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid ACombatCharacter::CheckCombo()\n{\n\t// are we playing a non-charge attack animation?\n\tif (bIsAttacking && !bIsChargingAttack)\n\t{\n\t\t// is the last attack input not stale?\n\t\tif (GetWorld()->GetTimeSeconds() - CachedAttackInputTime <= ComboInputCacheTimeTolerance)\n\t\t{\n\t\t\t// consume the attack input so we don't accidentally trigger it twice\n\t\t\tCachedAttackInputTime = 0.0f;\n\n\t\t\t// increase the combo counter\n\t\t\t++ComboCount;\n\n\t\t\t// do we still have a combo section to play?\n\t\t\tif (ComboCount < ComboSectionNames.Num())\n\t\t\t{\n\t\t\t\t// jump to the next combo section\n\t\t\t\tif (UAnimInstance* AnimInstance = GetMesh()->GetAnimInstance())\n\t\t\t\t{\n\t\t\t\t\tAnimInstance->Montage_JumpToSection(ComboSectionNames[ComboCount], ComboAttackMontage);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid ACombatCharacter::CheckChargedAttack()\n{\n\t// raise the looped charged attack flag\n\tbHasLoopedChargedAttack = true;\n\n\t// jump to either the loop or the attack section depending on whether we're still holding the charge button\n\tif (UAnimInstance* AnimInstance = GetMesh()->GetAnimInstance())\n\t{\n\t\tAnimInstance->Montage_JumpToSection(bIsChargingAttack ? ChargeLoopSection : ChargeAttackSection, ChargedAttackMontage);\n\t}\n}\n\nvoid ACombatCharacter::ApplyDamage(float Damage, AActor* DamageCauser, const FVector& DamageLocation, const FVector& DamageImpulse)\n{\n\t// pass the damage event to the actor\n\tFDamageEvent DamageEvent;\n\tconst float ActualDamage = TakeDamage(Damage, DamageEvent, nullptr, DamageCauser);\n\n\t// only process knockback and effects if we received nonzero damage\n\tif (ActualDamage > 0.0f)\n\t{\n\t\t// apply the knockback impulse\n\t\tGetCharacterMovement()->AddImpulse(DamageImpulse, true);\n\n\t\t// is the character ragdolling?\n\t\tif (GetMesh()->IsSimulatingPhysics())\n\t\t{\n\t\t\t// apply an impulse to the ragdoll\n\t\t\tGetMesh()->AddImpulseAtLocation(DamageImpulse * GetMesh()->GetMass(), DamageLocation);\n\t\t}\n\n\t\t// pass control to BP to play effects, etc.\n\t\tReceivedDamage(ActualDamage, DamageLocation, DamageImpulse.GetSafeNormal());\n\t}\n\n}\n\nvoid ACombatCharacter::HandleDeath()\n{\n\t// disable movement while we're dead\n\tGetCharacterMovement()->DisableMovement();\n\n\t// enable full ragdoll physics\n\tGetMesh()->SetSimulatePhysics(true);\n\n\t// hide the life bar\n\tLifeBar->SetHiddenInGame(true);\n\n\t// pull back the camera\n\tGetCameraBoom()->TargetArmLength = DeathCameraDistance;\n\n\t// schedule respawning\n\tGetWorld()->GetTimerManager().SetTimer(RespawnTimer, this, &ACombatCharacter::RespawnCharacter, RespawnTime, false);\n}\n\nvoid ACombatCharacter::ApplyHealing(float Healing, AActor* Healer)\n{\n\t// stub\n}\n\nvoid ACombatCharacter::RespawnCharacter()\n{\n\t// destroy the character and let it be respawned by the Player Controller\n\tDestroy();\n}\n\nfloat ACombatCharacter::TakeDamage(float Damage, struct FDamageEvent const& DamageEvent, AController* EventInstigator, AActor* DamageCauser)\n{\n\t// only process damage if the character is still alive\n\tif (CurrentHP <= 0.0f)\n\t{\n\t\treturn 0.0f;\n\t}\n\n\t// reduce the current HP\n\tCurrentHP -= Damage;\n\n\t// have we run out of HP?\n\tif (CurrentHP <= 0.0f)\n\t{\n\t\t// die\n\t\tHandleDeath();\n\t}\n\telse\n\t{\n\t\t// update the life bar\n\t\tLifeBarWidget->SetLifePercentage(CurrentHP / MaxHP);\n\n\t\t// enable partial ragdoll physics, but keep the pelvis vertical\n\t\tGetMesh()->SetPhysicsBlendWeight(0.5f);\n\t\tGetMesh()->SetBodySimulatePhysics(PelvisBoneName, false);\n\t}\n\n\t// return the received damage amount\n\treturn Damage;\n}\n\nvoid ACombatCharacter::Landed(const FHitResult& Hit)\n{\n\tSuper::Landed(Hit);\n\n\t// is the character still alive?\n\tif (CurrentHP >= 0.0f)\n\t{\n\t\t// disable ragdoll physics\n\t\tGetMesh()->SetPhysicsBlendWeight(0.0f);\n\t}\n}\n\nvoid ACombatCharacter::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t// get the life bar from the widget component\n\tLifeBarWidget = Cast<UCombatLifeBar>(LifeBar->GetUserWidgetObject());\n\tcheck(LifeBarWidget);\n\n\t// initialize the camera\n\tGetCameraBoom()->TargetArmLength = DefaultCameraDistance;\n\n\t// save the relative transform for the mesh so we can reset the ragdoll later\n\tMeshStartingTransform = GetMesh()->GetRelativeTransform();\n\n\t// set the life bar color\n\tLifeBarWidget->SetBarColor(LifeBarColor);\n\n\t// reset HP to maximum\n\tResetHP();\n}\n\nvoid ACombatCharacter::EndPlay(const EEndPlayReason::Type EndPlayReason)\n{\n\tSuper::EndPlay(EndPlayReason);\n\n\t// clear the respawn timer\n\tGetWorld()->GetTimerManager().ClearTimer(RespawnTimer);\n}\n\nvoid ACombatCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n\tSuper::SetupPlayerInputComponent(PlayerInputComponent);\n\n\t// Set up action bindings\n\tif (UEnhancedInputComponent* EnhancedInputComponent = Cast<UEnhancedInputComponent>(PlayerInputComponent))\n\t{\n\t\t// Moving\n\t\tEnhancedInputComponent->BindAction(MoveAction, ETriggerEvent::Triggered, this, &ACombatCharacter::Move);\n\n\t\t// Looking\n\t\tEnhancedInputComponent->BindAction(LookAction, ETriggerEvent::Triggered, this, &ACombatCharacter::Look);\n\t\tEnhancedInputComponent->BindAction(MouseLookAction, ETriggerEvent::Triggered, this, &ACombatCharacter::Look);\n\n\t\t// Combo Attack\n\t\tEnhancedInputComponent->BindAction(ComboAttackAction, ETriggerEvent::Started, this, &ACombatCharacter::ComboAttackPressed);\n\n\t\t// Charged Attack\n\t\tEnhancedInputComponent->BindAction(ChargedAttackAction, ETriggerEvent::Started, this, &ACombatCharacter::ChargedAttackPressed);\n\t\tEnhancedInputComponent->BindAction(ChargedAttackAction, ETriggerEvent::Completed, this, &ACombatCharacter::ChargedAttackReleased);\n\t}\n}\n\nvoid ACombatCharacter::NotifyControllerChanged()\n{\n\tSuper::NotifyControllerChanged();\n\n\t// update the respawn transform on the Player Controller\n\tif (ACombatPlayerController* PC = Cast<ACombatPlayerController>(GetController()))\n\t{\n\t\tPC->SetRespawnTransform(GetActorTransform());\n\t}\n}\n\n"}